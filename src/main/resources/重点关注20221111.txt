54,这个题的结束点很有意思，在什么时候跳出循环呢？
    一，官方给出的答案是list的size等于矩阵的所有元素总数，即跳出循环。
    二，想一想，如何求得最后一个坐标的位置呢？
55,题目是中等。初看是简单题，然后再看感觉很复杂，需要动用递归。结果递归超时……看官方解答，唉，好像确实是个简单题。
57,这题看似简单，其实注意的地方很多很多。然后看官方解法，又觉得好像没那么难……
132,这题的心得是啥？对于求最小值的问题，贪心算法,动态规划……
133,递归和广度优先，其实就是差着一个先进先出的队列
135,这题的精髓就是，每个同学有四个终态:1,处于升序中;2,处于降序中;3,处于升序及降序的波峰;4,处于升序及降序的波谷。
136,趁着这个题，学习一下Java的位运算吧。https://blog.csdn.net/weixin_39410864/article/details/123000487
139和140这两个题，有什么心得呢？答案那就是涉及字典的，肯定用Map<Integer,Set<String>>啊
141,Floyd 判圈算法,这个是啥
142,这题的解答在这里:https://leetcode.cn/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/
总体思路就是:
假设从起始位置到入口处的距离是a,环的周长是b,
当它们第一次相遇的时候,快针走了f步,慢针走了s步，则有如下公式:
f=2s
f=s+nb(慢针被套圈了，至于这个n是多少,有可能是1，有可能是多圈)
由上面的公式得出
s=nb
即慢针走了整整n个圈的距离。

如果从起始位置走到入口处，则需要走a+nb步，第一次到入口处走了a步，以后每多走一圈b步，就到了入口处
而慢针已经走了nb步，只需要再走a步即可到入口处。这a怎么求呢？
继续双指针，慢针往下走，然后快针从head开始，每次走一步,则走a步后，快针到了入口处，慢针同样走了a+nb步，到了入口处……
此时快针和慢针相遇……

精彩啊，精彩，奶奶的头，看了好多次，都记不住啊
145,二叉树的迭代算法，模拟了递归算法的压栈处理。也即后进先出规则。
因此我们用双端队列Deque的push(添加到首节点),pop(取首节点)方法模拟栈。
但是deque存放的数据到底是啥？真的好好理解过么？仔细想一想，deque存放的数据全部是左子树，
只有当需要处理当前节点的右子树的时候，才会把当前节点的右子树压进栈里。
149,这题里面有速求最大公约数的算法，一定要学会。同样，求得了最大公约数，那最小公倍数就是a*b除以最大公约数了
150,用数组模拟栈？
151,趁着这个题，学习下Java正则表达式:https://www.runoob.com/java/java-regular-expressions.html
152,这个题好好看看官方解答吧。这题居然可以用动态规划解？我已经晕过去了
153,谨记谨记，判断数组是否已经排好序，要用<=，不能漏了=号，因为可能起始位置和结束位置是同一个位置。这题居然还能用双指针解决……






