54,这个题的结束点很有意思，在什么时候跳出循环呢？
    一，官方给出的答案是list的size等于矩阵的所有元素总数，即跳出循环。
    二，想一想，如何求得最后一个坐标的位置呢？
55,题目是中等。初看是简单题，然后再看感觉很复杂，需要动用递归。结果递归超时……看官方解答，唉，好像确实是个简单题。
57,这题看似简单，其实注意的地方很多很多。然后看官方解法，又觉得好像没那么难……
132,这题的心得是啥？对于求最小值的问题，贪心算法,动态规划……
133,递归和广度优先，其实就是差着一个先进先出的队列
135,这题的精髓就是，每个同学有四个终态:1,处于升序中;2,处于降序中;3,处于升序及降序的波峰;4,处于升序及降序的波谷。
136,趁着这个题，学习一下Java的位运算吧。https://blog.csdn.net/weixin_39410864/article/details/123000487
139和140这两个题，有什么心得呢？答案那就是涉及字典的，肯定用Map<Integer,Set<String>>啊
141,Floyd 判圈算法,这个是啥
142,这题的解答在这里:https://leetcode.cn/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/
总体思路就是:
假设从起始位置到入口处的距离是a,环的周长是b,
当它们第一次相遇的时候,快针走了f步,慢针走了s步，则有如下公式:
f=2s
f=s+nb(慢针被套圈了，至于这个n是多少,有可能是1，有可能是多圈)
由上面的公式得出
s=nb
即慢针走了整整n个圈的距离。

如果从起始位置走到入口处，则需要走a+nb步，第一次到入口处走了a步，以后每多走一圈b步，就到了入口处
而慢针已经走了nb步，只需要再走a步即可到入口处。这a怎么求呢？
继续双指针，慢针往下走，然后快针从head开始，每次走一步,则走a步后，快针到了入口处，慢针同样走了a+nb步，到了入口处……
此时快针和慢针相遇……

精彩啊，精彩，奶奶的头，看了好多次，都记不住啊
145,二叉树的迭代算法，模拟了递归算法的压栈处理。也即后进先出规则。
因此我们用双端队列Deque的push(添加到首节点),pop(取首节点)方法模拟栈。
但是deque存放的数据到底是啥？真的好好理解过么？仔细想一想，deque存放的数据全部是左子树，
只有当需要处理当前节点的右子树的时候，才会把当前节点的右子树压进栈里。
149,这题里面有速求最大公约数的算法，一定要学会。同样，求得了最大公约数，那最小公倍数就是a*b除以最大公约数了
150,用数组模拟栈？
151,趁着这个题，学习下Java正则表达式:https://www.runoob.com/java/java-regular-expressions.html
152,这个题好好看看官方解答吧。这题居然可以用动态规划解？我已经晕过去了
153,谨记谨记，判断数组是否已经排好序，要用<=，不能漏了=号，因为可能起始位置和结束位置是同一个位置。这题居然还能用双指针解决……
164,排序算法，可以通过这篇文章学习下:https://blog.liuly.moe/posts/sort-algorithm
165,字符串分割，如果分割".",需要用"\\."，正则表达式真的不熟悉啊
166,这个题有时间好好看看吧，不会
167,这题的双指针解法，官方的解释通俗易懂。初始只知道把代码写出来，也有官方解释的担忧，但是自己没想通……
168,这个题虽然是个简单题，但是啥都不说了，一定要学会
169,投票法正确思路：不妨假设整个数组的众数记做a，则最初的数组中a的数量大于其余所有数。当采用count计数的时候有两种情况：
    1）假设candidate等于a，则当count从1变为0的过程，此区间内a的数量等于其余数的数量，因此以count=0为分界线，数组右端部分的众数仍然为a
    2）假设candidate不等于a，则当count从1变为0的过程， 此区间内a的数量小于等于其余数的数量，因此以count=0为分界线，数组右端部分的众数仍然为a
    因此，以count=0可以将整个原始数组分为若干部分，count=0右端部分的数组中的众数永远是a，最终必然会筛选出a
198,这个题如果标的不是中等题，我感觉这就是个简单题，奇数位累加和，偶数位累加和，比较返回……这题居然是个动态规划题……
200,这题绝对做过啊，和130题只是换了个形式
201,这个题要考察的是两个数的公共前缀。可以看下官方解答：https://leetcode.cn/problems/bitwise-and-of-numbers-range/solution/shu-zi-fan-wei-an-wei-yu-by-leetcode-solution/
203,递归的精髓：递归就是有去（递去）有回（归来）。
“有去”是指：递归问题必须可以分解为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决，就像上面例子中的钥匙可以打开后面所有门上的锁一样；
“有回”是指 : 这些问题的演化过程是一个从大到小，由近及远的过程，并且会有一个明确的终点(临界点)，一旦到达了这个临界点，就不用再往更小、更远的地方走下去。最后，从这个临界点开始，原路返回到原点，原问题解决。
递归的三要素：
1.明确递归终止条件；
2.给出递归终止时的处理办法；
3.提取重复的逻辑，缩小问题规模。
204,这个题解也好麻烦，看不懂，还需要看么？
205,这个简单题，感觉是个简单难度的中等题
206,递归方式好好看看
211,这题和208差不多。官网的写法真的是好啊
212,这题重新温故了前缀树，前缀树可以删除，这个牛逼了，确实牛逼
220,TreeSet,TreeMap,都好好的学习下吧，另外，堆排序什么的也好好学习下吧
221,这个题居然能用dp，dp真是神啊
224,想了一晚上想出来了，比官方解答差多了



